import OkHttpClient from "okhttp3.OkHttpClient";
import Request from "okhttp3.Request";
import Response from "okhttp3.Response";
import Callback from "okhttp3.Callback";
import Call from "okhttp3.Call";
import Gson from "com.google.gson.Gson";
import TypeToken from "com.google.gson.reflect.TypeToken";
import Serializable from "java.io.Serializable";
// import CookieManager from "java.net.CookieManager";
// import CookiePolicy from "java.net.CookiePolicy";
// import CookieStore from "java.net.CookieStore";
// import HttpCookie from "java.net.HttpCookie";
// import JavaNetCookieJar from "okhttp3.JavaNetCookieJar";
// import MutableList from "kotlin.collections.MutableList";
// import Cookie from "okhttp3.Cookie";
// import CookieJar from "okhttp3.CookieJar";
// import HttpUrl from "okhttp3.HttpUrl";

import { responseType, httpCallbacksType, paramsType } from "../interface.uts"
import IOException from "java.io.IOException";
import { CookieJarImpl } from "./CookieJarImpl.entity.uts"



// 错误：error: android.os.NetworkOnMainThreadException‌
// 不要在主线程中进行网络请求






// 初始化 okhttp
const client : OkHttpClient = new OkHttpClient.Builder()
	.cookieJar(new CookieJarImpl()).build();;

const gson = new Gson()


class CustomTypeToken<T> extends TypeToken<T> {
	constructor() {
		super();
	}
}


// type TestEntity = {
// 	aa : number
// 	bb : string
// }


class TestEntity {
	aa : number = 1
	bb : string = "钮海"
}




class CallbackIm<T1> extends Callback {

	private success : httpCallbacksType<T1>

	override  onFailure(call : Call, e : IOException) {
		console.log("Error", e);
	}


	override  onResponse(call : Call, response : Response) {
		const resBody = response.body!!.string()
		// console.log("body", resBody);



		// 产生utsObject 
		let retObj = new responseType<T1>()
		retObj.status = response.code
		retObj.data = resBody as T1
		retObj.message = response.message
		// const aaaa : T1 = retObj.data as T1
		// // console.log("????", aaaa);
		// retObj.data = aaaa

		// 希望产生kotlin对象
		// const str = gson.toJson(retObj)
		// console.log("转换后的字符串", str);
		// const type = new CustomTypeToken<responseType<T1>>().type
		// // console.log("type", type);
		// const bb = gson.fromJson<responseType<T1>>(str, type)
		// console.log("====对象", bb);





		// 测试
		// const testStr : TestEntity = {
		// 	aa: 1,
		// 	bb: "nihao"
		// }
		const testText = `{"aa":1,"bb":"nihao"}`
		// console.log("---测试 字符串", gson.toJson(testStr));
		// const testObj : TestEntity = gson.fromJson(testText, new CustomTypeToken<TestEntity>().type)
		const aa = gson.fromJson(testText, new CustomTypeToken<TestEntity>().type) as TestEntity
		console.log("---测试 对象", aa)


		// const str = "{\n" +
		// 	"    \"code\":0,\n" +
		// 	"    \"message\":\"\",\n" +
		// 	"    \"content\":{\n" +
		// 	"        \"city\":\"cheng du\",\n" +
		// 	"        \"weather\":\"sunny\",\n" +
		// 	"        \"tem\":16,\n" +
		// 	"        \"date\":\"2020-10-19\"\n" +
		// 	"    }\n" +
		// 	"}";

		// console.log("?????str", str);
		// const ttK = new CustomTypeToken<responseTypeTwo>()
		// const type = ttK.getType()
		// const gsonObj : responseTypeTwo = new Gson().fromJson<responseTypeTwo>(str, type)
		// console.log("转换后的对象", gsonObj);


		// {
		// 	status: response.code,
		// 	data: JSON.parse(response.body!!.string()) as T1,
		// 	message: response.message
		// }

		this.success(retObj)

	}


	constructor(success : httpCallbacksType<T1>) {
		super();
		this.success = success
	}
}


// export function okHttpGet(url : string) {






// 	const getRequest = new Request.Builder()
// 		.url(url)
// 		.build();
// 	client.newCall(getRequest).enqueue(new CallbackIm())
// }





// function aaaaaaaa(res:any){

// }


export class xxOkHttp {
	static request<T1>(params : paramsType<T1>) : void {
		const getRequest = new Request.Builder()
			.url(params.url)
			.build();
		client.newCall(getRequest).enqueue(new CallbackIm<T1>(params.success))
	}
}

// export const xxOkHttpaaaaa : xxOkHttpType<T1> = function<T1> (params : RequestOptions<T1>) {
// export



// export function xxOkHttp<T1, T2>(params : RequestOptions<T1>) : Promise<T2> {

// 	return new Promise((resolve, reject) => {






// 		const getRequest = new Request.Builder()
// 			.url(params.url)
// 			.build();
// 		client.newCall(getRequest).enqueue(new CallbackIm())
// 	})
// }