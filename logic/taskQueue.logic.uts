import { albumArrayData } from "../pages/index/index.data";
import { appConfig, staticData, appTaskStatus, globalData } from "../store/global.data";
import { taskQueueKeyName } from "../store/storage.key";
import { fileDetailType, matterPageReqType, matterPage, mkdirFileName, tankUploadFile } from "@/store/tank.movement.uts"
import { Album, albumUtil, mediaFile } from "@/uni_modules/photo-util";



/**
 * tank app 任务队列
 */
export type taskQueueType = {
	/**
	 * 任务类型
	 * 1: 同步任务，将本地所有需要备份的文件全部上传至 tank 服务器
	 */
	type : 1 | 2
	/**
	 * 状态
	 * 0：等待进行
	 * 1：正在进行
	 * 2：已完成
	 */
	status : 0 | 1 | 2
	/**
	 * 执行该任务可能需要的数据
	 */
	data ?: any
}



/**
 * tank app 任务队列
 */
export const tankTaskQueue = reactive([] as Array<taskQueueType>)



watch(tankTaskQueue, () => {
	// //console.log("---------！ 任务队列发生变化", tankTaskQueue);
	if (!appTaskStatus.taskQueueWorkIng) {
		startTaskQueue()
	}
}, {
	flush: 'post',
	// deep: true,
	// onTrack(e) {
	// },
	// onTrigger(e) {
	// }
})


/**
 * 任务队列工作函数
 */
function startTaskQueue() {
	// //console.log("开始备份上传咯！~1111111111", appTaskStatus.taskQueueWorkIng);

	appTaskStatus.taskQueueWorkIng = true



	// 1. 先拉取备份文件夹内所有的文件夹、文件列表
	// 2. 同本地需要备份的相册进行比对，将服务器上没有的文件统统上传，遇到同名冲突则重命名，始终保持服务端上拥有完整的文件
	// 附加、云上有的文件，本地没有的，则通过api拉倒本地显示（略缩图）
	// 3. 


	// 实现
	// 使用一个独立线程，分批的一个一个处理文件
	// 假设我有500个相册需要上传，全部一起处理完成后再一个个上传

	UTSAndroid.getDispatcher("io").async(function (_) {
		if (tankTaskQueue.length == 0) {
			appTaskStatus.taskQueueWorkIng = false
			return
		}

		upFileToTank()

	}, null)



}

async function upFileToTank() {
	console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!任务队列开始工作", tankTaskQueue);
	for (let t1 = 0; t1 < tankTaskQueue.length; t1++) {
		const tqItem = tankTaskQueue[t1]

		// 开始备份的条件
		// 1. 用户已经登录(服务端也登录，本地cookies有效)
		// 2. 备份线程没有正在工作
		// 3. 用户开启了备份
		if (appConfig.value.backup && tqItem.type == 1 && globalData.user.uuid != "" && (appTaskStatus.backups != 1 || appTaskStatus.backups != 0)) {
			appTaskStatus.backups = 1
			albumArrayData.allUpFileCount = 0
			albumArrayData.upFileCount = 0

			// 先统计本次总共需要上传多少
			const bakAlbumArr = albumArrayData.tankDataOnce
			bakAlbumArr.forEach((val) => {
				if (val.backups != 0) {
					albumArrayData.allUpFileCount += val.count
				}
			})

			const res = await matterPage({
				page: 0,
				pageSize: appConfig.value.maxPageSize,
				orderCreateTime: 'DESC',
				puuid: staticData.backupFile.uuid,
				deleted: false,
				orderDir: 'DESC'
			} as matterPageReqType)
			const serverFileArr : Array<fileDetailType> = res.data
			console.log("服务器上备份文件夹下所有文件夹、文件列表", serverFileArr);
			for (let i = 0; i < bakAlbumArr.length; i++) {
				const bakAlbum = bakAlbumArr[i]
				if (bakAlbum.backups != 0) {
					bakAlbum.backups = 1
					// 确定服务器上是否有该文件夹（相册）
					const serverFile = serverFileArr.find((svf) : boolean => svf["name"] == bakAlbum.name)
					if (serverFile == null) {
						// 创建一个文件夹
						const mkRes = await mkdirFileName(bakAlbum.name, staticData.backupFile.uuid)
						bakAlbum.uuid = mkRes.uuid
					} else if (bakAlbum.uuid != serverFile.uuid) {
						bakAlbum.uuid = serverFile.uuid
					}
					// 开始查询并且上传
					// 1. 查询 tank 服务器上该文件夹下所有文件
					const fileList = await matterPage({
						page: 0,
						pageSize: 9999,
						orderCreateTime: 'DESC',
						puuid: bakAlbum.uuid!,
						deleted: false,
						orderDir: 'DESC'
					} as matterPageReqType)
					console.log(` ----- 文件夹 ${bakAlbum.name} ${bakAlbum.uuid}`, fileList);
					// 2. 查询该相册列表下所有的文件
					// 3. 遍历文件，逐个对比，服务器没有的则上传
					const value = albumUtil.getAlbumsData(bakAlbum.correlationId)
					for (let i1 = 0; i1 < value.length; i1++) {
						// //console.log("---------!!!", value[i1].url.substringAfterLast('/'));
						const fileVal = value[i1]
						const serFile = fileList.data.find((svf) : boolean => svf["name"] == fileVal.url.substringAfterLast('/'))
						if (serFile == null) {
							console.log("需要上传", fileVal);
							await tankUploadFile(fileVal.url, staticData.backupFile.spaceUuid, bakAlbum.uuid!).catch((err)=>{
								console.log("上传api报错",err);
							})
							// 统计已上传数量
							albumArrayData.upFileCount++
						} else {
							console.log("不需要上传", fileVal)
							albumArrayData.upFileCount++
						}
					}
					bakAlbum.backups = 2
				}
			}
			appTaskStatus.backups = 2
			setTimeout(function () {
				appTaskStatus.backups = 3
			}, 10000);

		}
		// 完成备份任务，删除该条计划
		tankTaskQueue.splice(t1, 1)
		t1--
		
	}

	appTaskStatus.taskQueueWorkIng = false
	console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!队列工作完成");

}




/**
 * 任务队列初始化
 */
export function taskQueueInit() {
	// //console.log("-0-0-0-本地历史任务获取成功", tankTaskQueue);
	tankTaskQueue.push({
		type: 1,
		status: 0
	} as taskQueueType)
	// startTaskQueue()
	// uni.getStorage({
	// 	key: taskQueueKeyName,
	// 	success(res) {
	// 		// //console.log("-0-0-0-本地历史任务获取成功", res);
	// 		const arr : Array<taskQueueType> = JSON.parse<Array<taskQueueType>>(JSON.stringify(res.data))!
	// 		for (let i = 0; i < arr.length; i++) {
	// 			tankTaskQueue.push(arr[i])
	// 		}
	// 		// arr.forEach((val) => {
	// 		// 	
	// 		// })

	// 		startTaskQueue()
	// 	},
	// 	fail(err) {
	// 		//console.log("=-==-=-=-=获取失败", err);
	// 	}
	// })
}


/**
 * 任务队列存储本地
 */
export function setStoTaskQueue() {
	uni.setStorageSync(taskQueueKeyName, tankTaskQueue)
}