/**
 * tank app 应用配置文件发生改变时触发
 */
import { appConfig, appTaskStatus, globalData, staticData } from "../store/global.data";
import { fileDetailType, matterPageReqType, matterPage, mkdirFileName } from "@/store/tank.movement.uts"

watch(appConfig, () => {
	// console.log("---------！ 应用设置发生变化", appConfig.value);
	// 开始备份的条件
	// 1. 用户已经登录(服务端也登录，本地cookies有效)
	// 2. 备份线程没有正在工作
	// 3. 用户开启了备份
	// console.log("=================", typeof globalData.user.uuid, (appConfig.value.backup && appTaskStatus.backups == 0));
	if (appConfig.value.backup && appTaskStatus.backups == 0 && globalData.user.uuid != "") {
		backupsIng()
	}
})


/**
 * 开始备份
 */
function backupsIng() {
	if (appTaskStatus.backups == 1) {
		return
	}
	appTaskStatus.backups = 1

	// console.log("开始备份上传咯！~1111111111");

	// 1. 先拉取备份文件夹内所有的文件夹、文件列表
	// 2. 同本地需要备份的相册进行比对，将服务器上没有的文件统统上传，遇到同名冲突则重命名，始终保持服务端上拥有完整的文件
	// 附加、云上有的文件，本地没有的，则通过api拉倒本地显示（略缩图）
	// 3. 


	// 实现
	// 使用一个独立线程，分批的一个一个处理文件
	// 假设我有500个相册需要上传，全部一起处理完成后再一个个上传

	UTSAndroid.getDispatcher("io").async(function (_) {
		console.log("----------------`````当前任务执行在", Thread.currentThread().getName())


		matterPage({
			page: 0,
			pageSize: appConfig.value.maxPageSize,
			orderCreateTime: 'DESC',
			puuid: staticData.backupFile.uuid,
			deleted: false,
			orderDir: 'DESC'
		} as matterPageReqType).then(async (res) => {
			const serverFileArr : Array<fileDetailType> = res.data
			console.log("服务器上的所有文件夹列表", serverFileArr);
			const bakAlbumArr = appConfig.value.bakAlbumArr

			for (let i = 0; i < bakAlbumArr.length; i++) {
				const bakAlbum = bakAlbumArr[i]
				const serverFile = serverFileArr.find((svf) : boolean => svf["name"] == bakAlbum.name)
				if (serverFile == null) {
					// 创建一个文件夹
					const mkRes = await mkdirFileName(bakAlbum.name, staticData.backupFile.uuid)
					bakAlbum.uuid = mkRes.uuid
				} else {
					bakAlbum.uuid = serverFile.uuid
				}
				// 开始查询并且上传
				appTaskStatus.backups = 0
			}
		})
	}, null)



}